import numpy as np
from inp import validation
from utilities.ur import units
from density_model import DensityModel
from timer import Timer
<<<<<<< HEAD
from material import Material
import math
||||||| merged common ancestors
from material import Material
=======
from materials.material import Material
>>>>>>> upstream/master

class THComponent(object):

    """This class represents a component of the system it has material and
    geometric properties essential to thermal modeling and heat transfer in
    support of calculations related to the thermal hydraulics subblock
    """

    def __init__(self, name=None,
                 mat=Material(),
                 vol=0.0,#*units.meter**3,
                 T0=0.0,#*units.kelvin,
                 alpha_temp=0*units.delta_k/units.kelvin,
                 timer=Timer(),
                 heatgen=False,
                 power_tot=0*units.watt,
                 sph=False,
                 ri=0,#*units.meter,
                 ro=0,#*units.meter
                 ):
        """Initalizes a thermal hydraulic component.
        A thermal-hydraulic component will be treated as one "lump" in the
        lumped capacitance model.

        :param name: The name of the component (i.e., "fuel" or "cool")
        :type name: str.
        :param vol: The volume of the component
        :type vol: float meter**3
        :param T0: The initial temperature of the component
        :type T0: float.
        :param alpha_temp: temperature coefficient of reactivity
        :type alpha_temp: float
        :param timer: The timer instance for the sim
        :type timer: Timer object
        :param heatgen: is this component a heat generator (fuel)
        :type heatgen: bool
        :param adv: is this component losses heat from advection
        :type adv: bool
        :param advheat: heat transfered through advection(watts), positive if
        gain heat, negative is loss heat
        :param sph: is this component a spherical component, spherical equations
        for heatgen, conduction are different, post-processing is different too
        :type sph: bool
        :param ri and ro: inner radius and outer radius of the sph/annular component
        """
        self.name = name
        self.vol = vol
        self.mat = mat
        self.k = mat.k
        self.cp = mat.cp
        self.dm = mat.dm
        self.name = name
        self.timer = timer
        #self.T = #units.Quantity(np.zeros(shape=(timer.timesteps(),),
                                 #        dtype=float), 'kelvin')
        self.T = np.zeros(shape=(timer.timesteps(),), dtype=float)
        self.T[0] = T0
        self.T0=T0
        self.alpha_temp = alpha_temp.to('delta_k/kelvin')
        self.heatgen = heatgen
        self.power_tot = power_tot
        self.cond = {}
        self.conv = {}
<<<<<<< HEAD
        self.adv = {}
||||||| merged common ancestors
=======
        self.mass = {}
        self.cust = {}
>>>>>>> upstream/master
        self.prev_t_idx = 0
        self.convBC = {}
        self.sph = sph
        self.ri = ri
        self.ro = ro

    def mesh(self, size):
        '''cut a THComponent into a list of smaller component
        return: a list of components'''
        N = int(round((self.ro-self.ri)/size))
        #todo implement: assert (N*size).magnitude == (self.ro-self.ri).magnitude
        to_ret = []
        for i in range(0, N):
            ri = self.ri+i*size
            ro = self.ri+(i+1)*size
            vol = 4.0/3.0*math.pi*(ro**3-ri**3)
            power_tot = self.power_tot/self.vol*vol
            alpha_temp = self.alpha_temp/self.vol*vol
            to_ret.append(THComponent(name=self.name+'%d'%i,
                                      mat=self.mat,
                                      vol=vol,
                                      T0=self.T[0],
                                      alpha_temp=alpha_temp,
                                      timer=self.timer,
                                      heatgen=self.heatgen,
                                      power_tot=power_tot,
                                      sph=self.sph,
                                      ri=ri, ro=ro))
        return to_ret

    def temp(self, timestep):
        """The temperature of this component at the chosen timestep
        :param timestep: the timestep at which to query the temperature
        :type timestep: int
        :return: the temperature of the component at the chosen timestep
        :rtype: float, in units of kelvin
        """
        #validation.validate_ge("timestep", timestep, 0)
        #validation.validate_le("timestep", timestep, self.timer.timesteps())
        return self.T[timestep]

    def rho(self, timestep):
        """The density of this component's materials
        :param timestep: the timestep at which to query the temperature
        :type timestep: int
        :return: the density of this component
        :rtype: float, in units of $kg/m^3$
        """
        ret = self.dm.rho(self.temp(timestep))
        return ret

    def update_temp(self, timestep, temp):
        """Updates the temperature
        :param timestep: the timestep at which to query the temperature
        :type timestep: int
        :param temp: the new tempterature
        :type float: float, dimensionless
        """
        self.T[timestep] = temp
        self.prev_t_idx = timestep
        return self.T[timestep]

    def dtemp(self, timestep, T0_timestep):
        if self.prev_t_idx == 0:
            return 0.0*units.kelvin
        else:
            T0=self.T[T0_timestep]
            #print self.T[5400]
            #print 'self.T'
            #print self.T
            #TODO: hard coded initial steady state temp, at 49s with dt=0.01
            return self.T[timestep-1]-T0
        #return (self.T[self.prev_t_idx] - self.T[self.prev_t_idx-1])

    def temp_reactivity(self, timestep, T0_timestep):
        '''alpha_temp is converted to deltak/kelvin'''
        #print self.alpha_temp
        #print self.dtemp(timestep)
        return self.alpha_temp*self.dtemp(timestep, T0_timestep)

    def add_convection(self, env, h, area):
        self.conv[env] = {
            "h": h.to('joule/second/kelvin/meter**2'),
            "area": area
        }

    def addConvBC(self, env, prev_comp, h, R):
        self.convBC[env] = {
            "h": h.to('joule/second/kelvin/meter**2'),
            "prev_comp": prev_comp,
            "R": R
        }

    def add_conduction(self, env, k, area=0.0*units.meter**2, L=0.0*units.meter,
                       r_b=0.0*units.meter, r_env=0.0*units.meter):
        self.cond[env] = {
            "k": k.to('watts/meter/kelvin'),
            "area": area.to('meter**2'),
            "L": L.to('meter'),
            "r_b": r_b.to('meter'),
            "r_env": r_env.to('meter')
        }

<<<<<<< HEAD
    def add_advection(self, name, m_flow, t_in, cp):
        self.adv[name] = {
            "m_flow": m_flow.to('kg/second'),
            "t_in": t_in.to('kelvin'),
            "cp": cp.to('joule/kg/kelvin')
        }


class THSuperComponent(object):

    '''A component containing a list of component'''

    def __init__(self, name, T0, sub_comp=[], timer=Timer()):
        self.sub_comp = sub_comp
        self.name = name
        # for a super component, T is the outer surface temperature
        self.timer = timer
        self.T0 = T0
        #self.T = units.Quantity(np.zeros(shape=(timer.timesteps(),),
        #                                 dtype=float), 'kelvin')
        self.T = np.zeros(shape=(timer.timesteps(),), dtype=float)
        self.T[0] = T0
        self.conv = {}
    def update_temp_R(self, timestep, t_env, t_innercomp):
        """ TODO this function is not used
        Updates the temperature
        :param timestep: the timestep at which to query the temperature
        :type timestep: int
        :param temp: the new tempterature
        :type float: float, units of kelvin
        """
        tr=self.compute_tr(t_env, t_innercomp)
        self.T[timestep] =tr
        self.prev_t_idx = timestep
        return self.T[timestep]

    def update_temp(self, timestep, temp):
        """Updates the temperature
        :param timestep: the timestep at which to query the temperature
        :type timestep: int
        :param temp: the new tempterature
        :type float: float, dimensionless
        """
        self.T[timestep] = temp
        self.prev_t_idx = timestep
        return self.T[timestep]

    def compute_tr(self, t_env, t_innercomp):
        '''compute temperature at r=R for the sphere, from the temperature at r=R-dr
        and the temperature of the coolant
        '''
        for envname, d in self.conv.iteritems():
            h = self.conv[envname]["h"].magnitude
            k = self.conv[envname]["k"].magnitude
            dr = self.conv[envname]["dr"]
        return (-h/k*t_env+t_innercomp/dr)/(1/dr-h/k)

    def add_component(self, a_component):
        self.sub_comp.append(a_component)

    def add_conv_bc(self, envname, h):
        self.sub_comp[-2].addConvBC(envname,
                                   self.sub_comp[-1],
                                   h,
                                   (self.sub_comp)[-1].ro)
        self.conv[envname]= {'h': h,
                             'k' : self.sub_comp[-1].k,
                             'dr' : self.sub_comp[-1].ro-self.sub_comp[-1].ri
                             }

    def add_conduction_in_mesh(self):
        N = len(self.sub_comp)
        # element i=0:
        self.sub_comp[0].add_conduction(self.sub_comp[1].name, self.sub_comp[0].k)
        # element i=1:elementNb-3
        for i in range(1, N-2):
            self.sub_comp[i].add_conduction(self.sub_comp[i-1].name, self.sub_comp[i].k)
            self.sub_comp[i].add_conduction(self.sub_comp[i+1].name, self.sub_comp[i].k)
        # element i=elementNb-2
        self.sub_comp[N-2].add_conduction(self.sub_comp[N-3].name, self.sub_comp[N-2].k)
||||||| merged common ancestors
    def add_conduction(self, env, area):
        self.cond[env] = area.to('meter**2')
=======
    def add_conduction(self, env, area):
        self.cond[env] = area.to('meter**2')

    def add_mass_trans(self, env, H, u):
        self.mass[env] = {"H": H,
                          "u": u}

    def add_custom(self, env, res):
        self.cust[env] = {"res": res.to(units.kelvin/units.watt)}
>>>>>>> upstream/master
